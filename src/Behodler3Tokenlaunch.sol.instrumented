/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
/// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@vault/interfaces/IVault.sol";
import "./interfaces/IBondingToken.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// #invariant {:msg "Virtual K must be consistent with virtual pair product"} virtualK == 0 || virtualK == (virtualInputTokens + alpha) * (virtualL + beta);
///  #invariant {:msg "Virtual liquidity parameters must be properly initialized together"} (virtualK > 0 && alpha > 0 && beta > 0) || (virtualK == 0 && alpha == 0 && beta == 0);
///  #invariant {:msg "Contract cannot be locked and unlocked simultaneously"} locked == true || locked == false;
///  #invariant {:msg "Vault approval state must be consistent"} vaultApprovalInitialized == true || vaultApprovalInitialized == false;
///  #invariant {:msg "Seed input must always be zero (zero seed enforcement)"} seedInput == 0;
///  #invariant {:msg "Desired average price must be between 0 and 1e18 when set"} desiredAveragePrice == 0 || (desiredAveragePrice > 0 && desiredAveragePrice < 1e18);
///  #invariant {:msg "Virtual input tokens must be non-negative (starts at zero)"} virtualInputTokens >= 0;
///  #invariant {:msg "Vault balance consistency: approval must be initialized for operations"} !vaultApprovalInitialized || address(vault) != address(0);
///  #invariant {:msg "Bonding token total supply must not exceed reasonable mathematical limits"} bondingToken.totalSupply() <= virtualL + virtualInputTokens;
///  #invariant {:msg "Virtual K maintains mathematical integrity as constant product formula"} virtualK == 0 || virtualK > 0;
///  #invariant {:msg "Alpha and beta must be mathematically consistent for proper curve behavior"} alpha == 0 || beta == 0 || alpha == beta;
///  #invariant {:msg "Slippage protection: virtual parameters must be reasonable"}
///  alpha == 0 || alpha <= fundingGoal * 10;
///  #invariant {:msg "Token supply management: bonding token supply must not exceed funding goal"} fundingGoal == 0 || bondingToken.totalSupply() <= fundingGoal;
///  #invariant {:msg "Token supply consistency: total supply starts at zero and grows"} bondingToken.totalSupply() >= 0;
///  #invariant {:msg "Supply bounds: virtual L must be positive when virtual K is set"} virtualK == 0 || virtualL > 0;
///  #invariant {:msg "Cross-function state consistency: locked state must prevent all operations"}
///  !locked || (true);
///  #invariant {:msg "Add/remove liquidity state consistency: virtual pair maintains K invariant"}
///  virtualK == 0 || virtualK > 0;
///  #invariant {:msg "State consistency across operations: virtual input tokens should not exceed funding goal"}
///  virtualK == 0 || virtualInputTokens <= fundingGoal;
///  #invariant {:msg "Pre/post condition linkage: vault approval required for operations"}
///  !vaultApprovalInitialized || address(inputToken) != address(0);
///  #invariant {:msg "Cross-function invariant: virtual L and bonding token supply remain mathematically linked"}
///  virtualK == 0 || (virtualL > 0 && bondingToken.totalSupply() >= 0);
///  #invariant {:msg "Withdrawal fee must be within valid range (0 to 10000 basis points)"} withdrawalFeeBasisPoints >= 0 && withdrawalFeeBasisPoints <= 10000;
contract Behodler3Tokenlaunch is ReentrancyGuard, Ownable {
    event LiquidityAdded(address indexed user, uint256 inputAmount, uint256 bondingTokensOut);

    event LiquidityRemoved(address indexed user, uint256 bondingTokenAmount, uint256 inputTokensOut);

    event ContractLocked();

    event ContractUnlocked();

    event VaultChanged(address indexed oldVault, address indexed newVault);

    event VirtualLiquidityGoalsSet(uint256 fundingGoal, uint256 seedInput, uint256 desiredAveragePrice, uint256 alpha, uint256 beta, uint256 virtualK);

    event WithdrawalFeeUpdated(uint256 oldFee, uint256 newFee);

    event FeeCollected(address indexed user, uint256 bondingTokenAmount, uint256 feeAmount);

    struct vars9 {
        bool __scribble_check_invs_at_end;
    }

    struct vars13 {
        bool old_0;
    }

    struct vars14 {
        bool old_1;
    }

    struct vars16 {
        uint256 old_2;
        uint256 old_3;
    }

    struct vars17 {
        uint256 old_4;
        uint256 old_5;
        uint256 old_6;
        uint256 old_7;
        uint256 feeAmount1;
        bool let_0;
        uint256 feeAmount2;
        uint256 effectiveAmount;
        bool let_1;
        bool let_2;
    }

    struct vars19 {
        uint256 feeAmount3;
        uint256 effectiveBondingTokens1;
        bool let_3;
        bool let_4;
    }

    /// @notice The input token being bootstrapped
    IERC20 public inputToken;
    /// @notice The bonding token representing liquidity positions
    IBondingToken public bondingToken;
    /// @notice The vault contract for token storage
    IVault public vault;
    /// @notice Whether the contract is locked for emergency purposes
    bool public locked;
    /// @notice Whether the vault approval has been initialized
    bool public vaultApprovalInitialized;
    /// @notice Virtual amount of input tokens in the pair (starts at 10000)
    uint256 public virtualInputTokens;
    /// @notice Virtual amount of L tokens in the pair (starts at 100000000)
    uint256 public virtualL;
    /// @notice Virtual liquidity offset for input tokens (α)
    uint256 public alpha;
    /// @notice Virtual liquidity offset for bonding tokens (β)
    uint256 public beta;
    /// @notice Virtual liquidity constant product k for (x+α)(y+β)=k
    uint256 public virtualK;
    /// @notice Funding goal for virtual liquidity mode
    uint256 public fundingGoal;
    /// @notice Seed input amount for virtual liquidity mode
    uint256 public seedInput;
    /// @notice Desired average price for virtual liquidity mode (scaled by 1e18)
    uint256 public desiredAveragePrice;
    /// @notice Auto-lock functionality flag
    bool public autoLock;
    /// @notice Withdrawal fee in basis points (0-10000, where 10000 = 100%)
    uint256 public withdrawalFeeBasisPoints;

    modifier notLocked() {
        require(!locked, "B3: Contract is locked");
        _;
    }

    constructor(IERC20 _inputToken, IBondingToken _bondingToken, IVault _vault) Ownable(msg.sender) {
        __ScribbleUtilsLib__1741.setInContract(true);
        inputToken = _inputToken;
        bondingToken = _bondingToken;
        vault = _vault;
        vaultApprovalInitialized = false;
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function setGoals(uint256 _fundingGoal, uint256 _desiredAveragePrice) external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_setGoals(_fundingGoal, _desiredAveragePrice);
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("007064:0102:003 21: Only owner can call this function");
                assert(false);
            }
            if (!(_fundingGoal > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("007268:0098:003 22: Funding goal must be positive");
                assert(false);
            }
            if (!((_desiredAveragePrice >= 866025403784438647) && (_desiredAveragePrice < 1000000000000000000))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("007544:0126:003 23: Desired average price must be between sqrt(0.75) and 1e18");
                assert(false);
            }
            if (!(fundingGoal == _fundingGoal)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("007783:0105:003 24: Funding goal should be set correctly");
                assert(false);
            }
            if (!(seedInput == 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("007988:0106:003 25: Seed input should be enforced as zero");
                assert(false);
            }
            if (!(desiredAveragePrice == _desiredAveragePrice)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("008223:0114:003 26: Desired average price should be set correctly");
                assert(false);
            }
            if (!(alpha == ((_desiredAveragePrice * _fundingGoal) / (1000000000000000000 - _desiredAveragePrice)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("008518:0119:003 27: Alpha should be calculated correctly for zero seed");
                assert(false);
            }
            if (!(beta == alpha)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("008736:0092:003 28: Beta should equal alpha");
                assert(false);
            }
            if (!(virtualK == ((_fundingGoal + alpha) * (_fundingGoal + alpha)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("008975:0109:003 29: Virtual K should be calculated correctly");
                assert(false);
            }
            if (!(virtualInputTokens == 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("009193:0111:003 30: Virtual input tokens should be set to zero");
                assert(false);
            }
            if (!(virtualL == ((virtualK / alpha) - alpha))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("009430:0109:003 31: Virtual L should be calculated correctly");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_setGoals(uint256 _fundingGoal, uint256 _desiredAveragePrice) internal onlyOwner() {
        require(_fundingGoal > 0, "VL: Funding goal must be positive");
        require(_desiredAveragePrice >= 866025403784438647, "VL: Average price must be >= sqrt(0.75) for P0 >= 0.75");
        require(_desiredAveragePrice < 1e18, "VL: Average price must be < 1");
        fundingGoal = _fundingGoal;
        seedInput = 0;
        desiredAveragePrice = _desiredAveragePrice;
        uint256 numerator = (_desiredAveragePrice * _fundingGoal) / 1e18;
        uint256 denominator = 1e18 - _desiredAveragePrice;
        require(denominator > 0, "VL: Invalid average price (denominator would be zero)");
        alpha = (numerator * 1e18) / denominator;
        beta = alpha;
        uint256 xFinPlusAlpha = _fundingGoal + alpha;
        virtualK = xFinPlusAlpha * xFinPlusAlpha;
        require(alpha > 0, "VL: Alpha must be positive for calculations");
        virtualL = (virtualK / alpha) - alpha;
        virtualInputTokens = 0;
        emit VirtualLiquidityGoalsSet(_fundingGoal, 0, _desiredAveragePrice, alpha, beta, virtualK);
    }

    function getCurrentMarginalPrice() external returns (uint256 price) {
        __ScribbleUtilsLib__1741.setInContract(true);
        price = _original_Behodler3Tokenlaunch_getCurrentMarginalPrice();
        unchecked {
            if (!(virtualK > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("011147:0109:003 32: Virtual K must be set to calculate price");
                assert(false);
            }
            if (!((!(virtualK > 0)) || (price > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("011374:0113:003 33: Price must be positive when virtual K is set");
                assert(false);
            }
            if (!((!(virtualK > 0)) || (price == ((((virtualInputTokens + alpha) * (virtualInputTokens + alpha)) * 1000000000000000000) / virtualK)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("011703:0122:003 34: Price should be calculated using virtual pair formula");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_getCurrentMarginalPrice() internal view returns (uint256 price) {
        return _getCurrentMarginalPriceInternal();
    }

    function getAveragePrice() external returns (uint256 avgPrice) {
        __ScribbleUtilsLib__1741.setInContract(true);
        avgPrice = _original_Behodler3Tokenlaunch_getAveragePrice();
        unchecked {
            if (!((!(bondingToken.totalSupply() == 0)) || (avgPrice == 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("012463:0119:003 35: Average price is zero when no bonding tokens exist");
                assert(false);
            }
            if (!((!(bondingToken.totalSupply() > 0)) || (avgPrice == ((getTotalRaised() * 1000000000000000000) / bondingToken.totalSupply())))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("012792:0136:003 36: Average price calculation must be correct when bonding tokens exist");
                assert(false);
            }
            if (!(avgPrice <= type(uint256).max)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("013043:0123:003 37: Average price must be reasonable (not exceed max uint)");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_getAveragePrice() internal returns (uint256 avgPrice) {
        uint256 totalBondingTokens = bondingToken.totalSupply();
        if (totalBondingTokens == 0) return 0;
        uint256 totalRaised = getTotalRaised();
        avgPrice = (totalRaised * 1e18) / totalBondingTokens;
        return avgPrice;
    }

    function getTotalRaised() public returns (uint256 totalRaised) {
        vars9 memory _v;
        _v.__scribble_check_invs_at_end = !__ScribbleUtilsLib__1741.isInContract();
        __ScribbleUtilsLib__1741.setInContract(true);
        totalRaised = _original_Behodler3Tokenlaunch_getTotalRaised();
        unchecked {
            if (!(virtualK > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("014058:0118:003 38: Goals must be set before calculating total raised");
                assert(false);
            }
            if (!(totalRaised == virtualInputTokens)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("014295:0124:003 39: Total raised equals virtual input tokens with zero seed");
                assert(false);
            }
        }
        if (_v.__scribble_check_invs_at_end) __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(!_v.__scribble_check_invs_at_end);
    }

    function _original_Behodler3Tokenlaunch_getTotalRaised() internal view returns (uint256 totalRaised) {
        require(virtualK > 0, "VL: Goals not set - call setGoals first");
        return virtualInputTokens;
    }

    function getInitialMarginalPrice() external returns (uint256 initialPrice) {
        __ScribbleUtilsLib__1741.setInContract(true);
        initialPrice = _original_Behodler3Tokenlaunch_getInitialMarginalPrice();
        unchecked {
            if (!(desiredAveragePrice > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("015168:0129:003 40: Desired average price must be set to calculate initial price");
                assert(false);
            }
            if (!((!(desiredAveragePrice > 0)) || (initialPrice == ((desiredAveragePrice * desiredAveragePrice) / 1000000000000000000)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("015500:0125:003 41: Initial price should equal desired average price squared");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_getInitialMarginalPrice() internal view returns (uint256 initialPrice) {
        return _getInitialMarginalPriceInternal();
    }

    function getFinalMarginalPrice() external returns (uint256 finalPrice) {
        __ScribbleUtilsLib__1741.setInContract(true);
        finalPrice = _original_Behodler3Tokenlaunch_getFinalMarginalPrice();
        unchecked {
            if (!(finalPrice == 1000000000000000000)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("016264:0125:003 42: Final price must always be 1e18 (representing 1:1 ratio)");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_getFinalMarginalPrice() internal pure returns (uint256 finalPrice) {
        return 1e18;
    }

    ///  @notice Generalized quote calculation for virtual pair operations (DRY principle)
    ///  @dev Unified logic for both add and remove operations using virtual pair math formula
    ///  @param virtualFrom Current virtual amount of the token being reduced
    ///  @param virtualTo Current virtual amount of the token being increased
    ///  @param inputAmount Amount of tokens being added to virtualTo
    ///  @return outputAmount Amount of tokens that would be reduced from virtualFrom
    function _calculateVirtualPairQuote(uint256 virtualFrom, uint256 virtualTo, uint256 inputAmount) internal view returns (uint256 outputAmount) {
        require(virtualK > 0, "VL: Goals not set - call setGoals first");
        return _calculateVirtualLiquidityQuote(virtualFrom, virtualTo, inputAmount);
    }

    ///  @notice Calculate quote using virtual liquidity formula (x+α)(y+β)=k
    ///  @dev Implements the offset bonding curve mathematics
    ///  @param virtualFrom Current virtual amount of the token being reduced
    ///  @param virtualTo Current virtual amount of the token being increased
    ///  @param inputAmount Amount of tokens being added to virtualTo
    ///  @return outputAmount Amount of tokens that would be reduced from virtualFrom
    function _calculateVirtualLiquidityQuote(uint256 virtualFrom, uint256 virtualTo, uint256 inputAmount) internal view returns (uint256 outputAmount) {
        if ((seedInput == 0) && (beta == alpha)) {
            return _calculateVirtualLiquidityQuoteOptimized(virtualFrom, virtualTo, inputAmount);
        }
        return _calculateVirtualLiquidityQuoteGeneral(virtualFrom, virtualTo, inputAmount);
    }

    ///  @notice Optimized virtual liquidity calculation for zero seed case
    ///  @dev Gas-optimized version when seedInput = 0 and β = α
    ///  @param virtualFrom Current virtual amount of the token being reduced
    ///  @param virtualTo Current virtual amount of the token being increased
    ///  @param inputAmount Amount of tokens being added to virtualTo
    ///  @return outputAmount Amount of tokens that would be reduced from virtualFrom
    function _calculateVirtualLiquidityQuoteOptimized(uint256 virtualFrom, uint256 virtualTo, uint256 inputAmount) internal view returns (uint256 outputAmount) {
        uint256 denominator = (virtualTo + inputAmount) + alpha;
        uint256 newVirtualFromWithOffset = virtualK / denominator;
        require(newVirtualFromWithOffset >= alpha, "VL: Subtraction would underflow");
        uint256 newVirtualFrom = newVirtualFromWithOffset - alpha;
        require(virtualFrom >= newVirtualFrom, "VL: Subtraction would underflow");
        outputAmount = virtualFrom - newVirtualFrom;
        return outputAmount;
    }

    ///  @notice General virtual liquidity calculation (original implementation)
    ///  @dev Used as fallback for non-optimized cases
    ///  @param virtualFrom Current virtual amount of the token being reduced
    ///  @param virtualTo Current virtual amount of the token being increased
    ///  @param inputAmount Amount of tokens being added to virtualTo
    ///  @return outputAmount Amount of tokens that would be reduced from virtualFrom
    function _calculateVirtualLiquidityQuoteGeneral(uint256 virtualFrom, uint256 virtualTo, uint256 inputAmount) internal view returns (uint256 outputAmount) {
        uint256 fromOffset;
        uint256 toOffset;
        if (virtualFrom == virtualInputTokens) {
            fromOffset = alpha;
            toOffset = beta;
        } else {
            fromOffset = beta;
            toOffset = alpha;
        }
        require(virtualTo <= (type(uint256).max - inputAmount), "VL: Addition would overflow");
        require((virtualTo + inputAmount) <= (type(uint256).max - toOffset), "VL: Addition would overflow");
        uint256 denominator = (virtualTo + inputAmount) + toOffset;
        require(denominator > 0, "VL: Zero denominator");
        uint256 newVirtualFromWithOffset = virtualK / denominator;
        require(newVirtualFromWithOffset >= fromOffset, "VL: Subtraction would underflow");
        uint256 newVirtualFrom = newVirtualFromWithOffset - fromOffset;
        require(newVirtualFrom < virtualFrom, "VL: Invalid calculation result");
        outputAmount = virtualFrom - newVirtualFrom;
        return outputAmount;
    }

    ///  @notice Check that marginal price is within expected bounds
    ///  @dev Ensures price doesn't go below initial or above final bounds
    function _checkPriceBounds() internal view {
        require(virtualK > 0, "VL: Goals not set - call setGoals first");
        uint256 currentPrice = _getCurrentMarginalPriceInternal();
        uint256 initialPrice = _getInitialMarginalPriceInternal();
        uint256 finalPrice = 1e18;
        require(currentPrice >= initialPrice, "VL: Price below initial bound");
        require(currentPrice <= finalPrice, "VL: Price above final bound");
    }

    ///  @notice Internal function to get current marginal price (optimized for zero seed)
    ///  @dev Used internally to avoid external call issues. Optimized for x₀ = 0 case.
    function _getCurrentMarginalPriceInternal() internal view returns (uint256 price) {
        require(virtualK > 0, "VL: Goals not set - call setGoals first");
        uint256 xPlusAlpha = virtualInputTokens + alpha;
        unchecked {
            price = ((xPlusAlpha * xPlusAlpha) * 1e18) / virtualK;
        }
        return price;
    }

    ///  @notice Internal function to get initial marginal price (optimized for zero seed)
    ///  @dev Used internally to avoid external call issues. Zero seed optimization: P₀ = P_avg²
    function _getInitialMarginalPriceInternal() internal view returns (uint256 initialPrice) {
        require(desiredAveragePrice > 0, "VL: Goals not set - call setGoals first");
        unchecked {
            initialPrice = (desiredAveragePrice * desiredAveragePrice) / 1e18;
        }
        return initialPrice;
    }

    ///  @notice Update virtual pair state for virtual liquidity mode
    ///  @dev Updates state using virtual liquidity formula instead of traditional xy=k
    ///  @param inputTokenDelta Change in input tokens (positive for add, negative for remove)
    ///  @param bondingTokenDelta Change in bonding tokens (negative for add, positive for remove)
    function _updateVirtualLiquidityState(int256 inputTokenDelta, int256 bondingTokenDelta) internal {
        require(virtualK > 0, "VL: Goals not set - call setGoals first");
        if (inputTokenDelta >= 0) {
            virtualInputTokens += uint256(inputTokenDelta);
        } else {
            virtualInputTokens -= uint256(-inputTokenDelta);
        }
        if (bondingTokenDelta >= 0) {
            virtualL += uint256(bondingTokenDelta);
        } else {
            virtualL -= uint256(-bondingTokenDelta);
        }
        _checkPriceBounds();
    }

    function setInputToken(address _token) external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_setInputToken(_token);
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("023848:0099:003 43: Only owner can set input token");
                assert(false);
            }
            if (!(_token != address(0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("024053:0105:003 44: Input token address must not be zero");
                assert(false);
            }
            if (!(address(inputToken) == _token)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("024273:0113:003 45: Input token should be updated to new address");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_setInputToken(address _token) internal onlyOwner() {
        _setInputToken(IERC20(_token));
    }

    function _setInputToken(IERC20 _token) internal {
        inputToken = _token;
        if (vaultApprovalInitialized) {
            require(_callsite_1168(inputToken, address(vault), type(uint256).max), "B3: Approve failed");
        }
    }

    function initializeVaultApproval() external {
        vars13 memory _v;
        __ScribbleUtilsLib__1741.setInContract(true);
        unchecked {
            _v.old_0 = vaultApprovalInitialized;
        }
        _original_Behodler3Tokenlaunch_initializeVaultApproval();
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("025295:0109:003 46: Only owner can initialize vault approval");
                assert(false);
            }
            if (!(!_v.old_0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("025499:0111:003 47: Vault approval was not already initialized");
                assert(false);
            }
            if (!(vaultApprovalInitialized == true)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("025728:0116:003 48: Vault approval should be initialized after call");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_initializeVaultApproval() internal onlyOwner() {
        require(!vaultApprovalInitialized, "B3: Vault approval already initialized");
        require(_callsite_1199(inputToken, address(vault), type(uint256).max), "B3: Vault approval failed");
        vaultApprovalInitialized = true;
    }

    function disableToken() external {
        vars14 memory _v;
        __ScribbleUtilsLib__1741.setInContract(true);
        unchecked {
            _v.old_1 = vaultApprovalInitialized;
        }
        _original_Behodler3Tokenlaunch_disableToken();
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("026677:0097:003 49: Only owner can disable token");
                assert(false);
            }
            if (!(_v.old_1)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("026868:0120:003 50: Vault approval must be initialized before disabling");
                assert(false);
            }
            if (!(vaultApprovalInitialized == false)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("027107:0113:003 51: Vault approval should be disabled after call");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_disableToken() internal onlyOwner() {
        require(vaultApprovalInitialized, "B3: Vault approval not initialized");
        require(_callsite_1227(inputToken, address(vault), 0), "B3: Approval revocation failed");
        vaultApprovalInitialized = false;
    }

    function setVault(address _vault) external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_setVault(_vault);
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("027934:0093:003 52: Only owner can set vault");
                assert(false);
            }
            if (!(_vault != address(0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("028133:0099:003 53: Vault address must not be zero");
                assert(false);
            }
            if (!(address(vault) == _vault)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("028342:0107:003 54: Vault should be updated to new address");
                assert(false);
            }
            if (!(vaultApprovalInitialized == false)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("028568:0105:003 55: Vault approval state should be reset");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_setVault(address _vault) internal onlyOwner() {
        _setVault(IVault(_vault));
    }

    ///  @notice Internal function to set the vault address
    ///  @dev Sets vault address and resets approval state for security
    ///  @param _vault The new vault contract address
    function _setVault(IVault _vault) internal {
        address oldVault = address(vault);
        vault = _vault;
        vaultApprovalInitialized = false;
        emit VaultChanged(oldVault, address(_vault));
    }

    ///  @notice Calculate bonding tokens output for a given input amount using virtual pair math
    ///  @dev Uses generalized quote logic to eliminate duplication across quote system
    ///  @param inputAmount Amount of input tokens being added
    ///  @return bondingTokensOut Amount of bonding tokens that would be minted
    function _calculateBondingTokensOut(uint256 inputAmount) internal view returns (uint256 bondingTokensOut) {
        bondingTokensOut = _calculateVirtualPairQuote(virtualL, virtualInputTokens, inputAmount);
        return bondingTokensOut;
    }

    ///  @notice Calculate input tokens output for a given bonding token amount using virtual pair math
    ///  @dev Uses generalized quote logic to eliminate duplication across quote system
    ///  @param bondingTokenAmount Amount of bonding tokens being burned
    ///  @return inputTokensOut Amount of input tokens that would be received
    function _calculateInputTokensOut(uint256 bondingTokenAmount) internal view returns (uint256 inputTokensOut) {
        if (virtualInputTokens == 0) {
            return 0;
        }
        inputTokensOut = _calculateVirtualPairQuote(virtualInputTokens, virtualL, bondingTokenAmount);
        return inputTokensOut;
    }

    function addLiquidity(uint256 inputAmount, uint256 minBondingTokens) external returns (uint256 bondingTokensOut) {
        vars16 memory _v;
        __ScribbleUtilsLib__1741.setInContract(true);
        unchecked {
            _v.old_2 = bondingToken.balanceOf(msg.sender);
            _v.old_3 = virtualInputTokens;
        }
        bondingTokensOut = _original_Behodler3Tokenlaunch_addLiquidity(inputAmount, minBondingTokens);
        unchecked {
            if (!(inputAmount > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("031133:0098:003 56: Input amount must be positive");
                assert(false);
            }
            if (!(!locked)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("031324:0096:003 57: Contract must not be locked");
                assert(false);
            }
            if (!(vaultApprovalInitialized)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("031530:0103:003 58: Vault approval must be initialized");
                assert(false);
            }
            if (!(virtualK > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("031731:0110:003 59: Virtual K must be set (goals initialized)");
                assert(false);
            }
            if (!(bondingTokensOut >= minBondingTokens)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("031963:0105:003 60: Output must meet minimum requirement");
                assert(false);
            }
            if (!((!(bondingTokensOut > 0)) || (bondingToken.balanceOf(msg.sender) >= (_v.old_2 + bondingTokensOut)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("032252:0106:003 61: Bonding tokens must be minted to user");
                assert(false);
            }
            if (!(virtualInputTokens > _v.old_3)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("032473:0105:003 62: Virtual input tokens should increase");
                assert(false);
            }
            if (!(inputAmount <= inputToken.balanceOf(msg.sender))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("032711:0114:003 63: User must have sufficient input token balance");
                assert(false);
            }
            if (!(inputAmount <= inputToken.allowance(msg.sender, address(this)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("032973:0104:003 64: User must have sufficient allowance");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_addLiquidity(uint256 inputAmount, uint256 minBondingTokens) internal nonReentrant() notLocked() returns (uint256 bondingTokensOut) {
        require(inputAmount > 0, "B3: Input amount must be greater than 0");
        require(vaultApprovalInitialized, "B3: Vault approval not initialized - call initializeVaultApproval() first");
        bondingTokensOut = _calculateBondingTokensOut(inputAmount);
        require(bondingTokensOut >= minBondingTokens, "B3: Insufficient output amount");
        require(_callsite_1376(inputToken, msg.sender, address(this), inputAmount), "B3: Transfer failed");
        _callsite_1392(vault, address(inputToken), inputAmount, address(this));
        if (bondingTokensOut > 0) {
            _callsite_1403(bondingToken, msg.sender, bondingTokensOut);
        }
        _updateVirtualLiquidityState(int256(inputAmount), -int256(bondingTokensOut));
        emit LiquidityAdded(msg.sender, inputAmount, bondingTokensOut);
        return bondingTokensOut;
    }

    function removeLiquidity(uint256 bondingTokenAmount, uint256 minInputTokens) external returns (uint256 inputTokensOut) {
        vars17 memory _v;
        __ScribbleUtilsLib__1741.setInContract(true);
        unchecked {
            _v.old_4 = bondingToken.balanceOf(msg.sender);
            _v.old_5 = virtualInputTokens;
            _v.old_6 = inputToken.balanceOf(msg.sender);
            _v.old_7 = bondingToken.totalSupply();
        }
        inputTokensOut = _original_Behodler3Tokenlaunch_removeLiquidity(bondingTokenAmount, minInputTokens);
        unchecked {
            if (!(bondingTokenAmount > 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("034911:0106:003 65: Bonding token amount must be positive");
                assert(false);
            }
            if (!(!locked)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("035110:0096:003 66: Contract must not be locked");
                assert(false);
            }
            if (!(bondingTokenAmount <= bondingToken.balanceOf(msg.sender))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("035348:0109:003 67: User must have sufficient bonding tokens");
                assert(false);
            }
            if (!(inputTokensOut >= minInputTokens)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("035575:0105:003 68: Output must meet minimum requirement");
                assert(false);
            }
            if (!(bondingToken.balanceOf(msg.sender) == (_v.old_4 - bondingTokenAmount))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("035835:0111:003 69: User bonding token balance should decrease");
                assert(false);
            }
            if (!((!(inputTokensOut > 0)) || (virtualInputTokens < _v.old_5))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("036090:0119:003 70: Virtual input tokens should decrease if output > 0");
                assert(false);
            }
            if (!((!(inputTokensOut > 0)) || (inputToken.balanceOf(msg.sender) >= (_v.old_6 + inputTokensOut)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("036387:0125:003 71: Input tokens should be transferred to user if output > 0");
                assert(false);
            }
            if (!(bondingToken.totalSupply() == (_v.old_7 - bondingTokenAmount))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("036659:0141:003 72: Total supply must decrease by full bonding token amount (including fees)");
                assert(false);
            }
            _v.feeAmount1 = (bondingTokenAmount * withdrawalFeeBasisPoints) / 10000;
            _v.let_0 = (_v.feeAmount1 >= 0) && (_v.feeAmount1 <= bondingTokenAmount);
            if (!(_v.let_0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("037065:0122:003 73: Fee calculation must be correct based on basis points");
                assert(false);
            }
            _v.feeAmount2 = (bondingTokenAmount * withdrawalFeeBasisPoints) / 10000;
            _v.effectiveAmount = bondingTokenAmount - _v.feeAmount2;
            _v.let_1 = (_v.effectiveAmount >= 0) && (_v.effectiveAmount <= bondingTokenAmount);
            _v.let_2 = _v.let_1;
            if (!(_v.let_2)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("037564:0126:003 74: Effective bonding tokens must equal full amount minus fee");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_removeLiquidity(uint256 bondingTokenAmount, uint256 minInputTokens) internal nonReentrant() notLocked() returns (uint256 inputTokensOut) {
        require(bondingTokenAmount > 0, "B3: Bonding token amount must be greater than 0");
        require(bondingToken.balanceOf(msg.sender) >= bondingTokenAmount, "B3: Insufficient bonding tokens");
        uint256 feeAmount = (bondingTokenAmount * withdrawalFeeBasisPoints) / 10000;
        uint256 effectiveBondingTokens = bondingTokenAmount - feeAmount;
        inputTokensOut = _calculateInputTokensOut(effectiveBondingTokens);
        require(inputTokensOut >= minInputTokens, "B3: Insufficient output amount");
        _callsite_1495(bondingToken, msg.sender, bondingTokenAmount);
        if (feeAmount > 0) {
            emit FeeCollected(msg.sender, bondingTokenAmount, feeAmount);
        }
        if (inputTokensOut > 0) {
            _callsite_1524(vault, address(inputToken), inputTokensOut, address(this));
            require(_callsite_1532(inputToken, msg.sender, inputTokensOut), "B3: Transfer failed");
        }
        _updateVirtualLiquidityState(-int256(inputTokensOut), int256(bondingTokenAmount));
        emit LiquidityRemoved(msg.sender, bondingTokenAmount, inputTokensOut);
        return inputTokensOut;
    }

    function quoteAddLiquidity(uint256 inputAmount) external returns (uint256 bondingTokensOut) {
        __ScribbleUtilsLib__1741.setInContract(true);
        bondingTokensOut = _original_Behodler3Tokenlaunch_quoteAddLiquidity(inputAmount);
        unchecked {
            if (!((!(inputAmount == 0)) || (bondingTokensOut == 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("039528:0102:003 75: Quote returns zero for zero input");
                assert(false);
            }
            if (!((!(inputAmount > 0)) || (virtualK > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("039754:0109:003 76: Virtual K must be set to calculate quote");
                assert(false);
            }
            if (!((!((inputAmount > 0) && (virtualK > 0))) || (bondingTokensOut > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("040015:0137:003 77: Quote should return positive tokens for positive input when K is set");
                assert(false);
            }
            if (!(true)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("040242:0137:003 78: Quote calculation should be consistent with addLiquidity calculation");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_quoteAddLiquidity(uint256 inputAmount) internal view returns (uint256 bondingTokensOut) {
        if (inputAmount == 0) return 0;
        bondingTokensOut = _calculateBondingTokensOut(inputAmount);
        return bondingTokensOut;
    }

    function quoteRemoveLiquidity(uint256 bondingTokenAmount) external returns (uint256 inputTokensOut) {
        vars19 memory _v;
        __ScribbleUtilsLib__1741.setInContract(true);
        inputTokensOut = _original_Behodler3Tokenlaunch_quoteRemoveLiquidity(bondingTokenAmount);
        unchecked {
            if (!((!(bondingTokenAmount == 0)) || (inputTokensOut == 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("041221:0111:003 79: Quote returns zero for zero bonding tokens");
                assert(false);
            }
            if (!((!(bondingTokenAmount > 0)) || (virtualK > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("041463:0109:003 80: Virtual K must be set to calculate quote");
                assert(false);
            }
            if (!((!((bondingTokenAmount > 0) && (virtualK > 0))) || (inputTokensOut >= 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("041730:0137:003 81: Quote should return positive tokens for positive input when K is set");
                assert(false);
            }
            _v.feeAmount3 = (bondingTokenAmount * withdrawalFeeBasisPoints) / 10000;
            _v.effectiveBondingTokens1 = bondingTokenAmount - _v.feeAmount3;
            _v.let_3 = inputTokensOut == _calculateInputTokensOut(_v.effectiveBondingTokens1);
            _v.let_4 = _v.let_3;
            if (!(_v.let_4)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("042251:0160:003 82: Quote calculation should be consistent with removeLiquidity calculation accounting for fees");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_quoteRemoveLiquidity(uint256 bondingTokenAmount) internal view returns (uint256 inputTokensOut) {
        if (bondingTokenAmount == 0) return 0;
        uint256 feeAmount = (bondingTokenAmount * withdrawalFeeBasisPoints) / 10000;
        uint256 effectiveBondingTokens = bondingTokenAmount - feeAmount;
        inputTokensOut = _calculateInputTokensOut(effectiveBondingTokens);
        return inputTokensOut;
    }

    function lock() external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_lock();
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("043247:0101:003 83: Only owner can lock the contract");
                assert(false);
            }
            if (!(locked == true)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("043448:0114:003 84: Contract should be locked after function call");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_lock() internal onlyOwner() {
        locked = true;
        emit ContractLocked();
    }

    function unlock() external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_unlock();
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("044077:0103:003 85: Only owner can unlock the contract");
                assert(false);
            }
            if (!(locked == false)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("044281:0116:003 86: Contract should be unlocked after function call");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_unlock() internal onlyOwner() {
        locked = false;
        emit ContractUnlocked();
    }

    function setAutoLock(bool _autoLock) external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_setAutoLock(_autoLock);
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("044950:0097:003 87: Only owner can set auto-lock");
                assert(false);
            }
            if (!(autoLock == _autoLock)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("045154:0111:003 88: Auto-lock should be set to specified value");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_setAutoLock(bool _autoLock) internal onlyOwner() {
        autoLock = _autoLock;
    }

    function setWithdrawalFee(uint256 _feeBasisPoints) external {
        __ScribbleUtilsLib__1741.setInContract(true);
        _original_Behodler3Tokenlaunch_setWithdrawalFee(_feeBasisPoints);
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("045835:0102:003 89: Only owner can set withdrawal fee");
                assert(false);
            }
            if (!(_feeBasisPoints <= 10000)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("046047:0099:003 90: Fee must be within valid range");
                assert(false);
            }
            if (!(withdrawalFeeBasisPoints == _feeBasisPoints)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("046275:0114:003 91: Withdrawal fee should be updated to new value");
                assert(false);
            }
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("046496:0121:003 92: Access control: only owner can modify withdrawal fee");
                assert(false);
            }
            if (!((_feeBasisPoints >= 0) && (_feeBasisPoints <= 10000))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("046755:0126:003 93: Fee parameter validation: new fee must not exceed maximum");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_setWithdrawalFee(uint256 _feeBasisPoints) internal onlyOwner() {
        require(_feeBasisPoints <= 10000, "B3: Fee must be <= 10000 basis points");
        uint256 oldFee = withdrawalFeeBasisPoints;
        withdrawalFeeBasisPoints = _feeBasisPoints;
        emit WithdrawalFeeUpdated(oldFee, _feeBasisPoints);
    }

    function getVirtualPair() external returns (uint256 inputTokens, uint256 lTokens, uint256 k) {
        __ScribbleUtilsLib__1741.setInContract(true);
        (inputTokens, lTokens, k) = _original_Behodler3Tokenlaunch_getVirtualPair();
        unchecked {
            if (!(inputTokens == virtualInputTokens)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("047738:0110:003 94: Input tokens should match virtual storage");
                assert(false);
            }
            if (!(lTokens == virtualL)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("047953:0106:003 95: L tokens should match virtual storage");
                assert(false);
            }
            if (!(k == virtualK)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("048158:0115:003 96: K should return the virtual liquidity constant");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_getVirtualPair() internal view returns (uint256 inputTokens, uint256 lTokens, uint256 k) {
        return (virtualInputTokens, virtualL, virtualK);
    }

    function isVirtualPairInitialized() external returns (bool RET_0) {
        __ScribbleUtilsLib__1741.setInContract(true);
        RET_0 = _original_Behodler3Tokenlaunch_isVirtualPairInitialized();
        unchecked {
            if (!(RET_0 == (((virtualK > 0) && (alpha > 0)) && (beta > 0)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("048952:0130:003 97: Initialization requires all virtual parameters to be positive");
                assert(false);
            }
            if (!((!RET_0) || (virtualK > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("049194:0111:003 98: If initialized, virtual K must be positive");
                assert(false);
            }
            if (!((!RET_0) || (alpha > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("049414:0107:003 99: If initialized, alpha must be positive");
                assert(false);
            }
            if (!((!RET_0) || (beta > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("049629:0107:003 100: If initialized, beta must be positive");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_isVirtualPairInitialized() internal view returns (bool) {
        return ((virtualK > 0) && (alpha > 0)) && (beta > 0);
    }

    function virtualLDifferentFromTotalSupply() external returns (bool RET_0) {
        __ScribbleUtilsLib__1741.setInContract(true);
        RET_0 = _original_Behodler3Tokenlaunch_virtualLDifferentFromTotalSupply();
        unchecked {
            if (!(RET_0 == (virtualL != bondingToken.totalSupply()))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("050396:0138:003 101: Result should reflect difference between virtual L and actual supply");
                assert(false);
            }
            if (!(true)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("050624:0144:003 102: Virtual pair architecture requires separation of virtual and actual tokens");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
    }

    function _original_Behodler3Tokenlaunch_virtualLDifferentFromTotalSupply() internal view returns (bool) {
        return virtualL != bondingToken.totalSupply();
    }

    /// Check only the current contract's state invariants
    function __scribble_Behodler3Tokenlaunch_check_state_invariants_internal() internal {
        unchecked {
            if (!((virtualK == 0) || (virtualK == ((virtualInputTokens + alpha) * (virtualL + beta))))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("051395:0122:003 0: Virtual K must be consistent with virtual pair product");
                assert(false);
            }
            if (!((((virtualK > 0) && (alpha > 0)) && (beta > 0)) || (((virtualK == 0) && (alpha == 0)) && (beta == 0)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("051704:0134:003 1: Virtual liquidity parameters must be properly initialized together");
                assert(false);
            }
            if (!((locked == true) || (locked == false))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("051961:0121:003 2: Contract cannot be locked and unlocked simultaneously");
                assert(false);
            }
            if (!((vaultApprovalInitialized == true) || (vaultApprovalInitialized == false))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("052241:0107:003 3: Vault approval state must be consistent");
                assert(false);
            }
            if (!(seedInput == 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("052448:0122:003 4: Seed input must always be zero (zero seed enforcement)");
                assert(false);
            }
            if (!((desiredAveragePrice == 0) || ((desiredAveragePrice > 0) && (desiredAveragePrice < 1000000000000000000)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("052760:0125:003 5: Desired average price must be between 0 and 1e18 when set");
                assert(false);
            }
            if (!(virtualInputTokens >= 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("052994:0126:003 6: Virtual input tokens must be non-negative (starts at zero)");
                assert(false);
            }
            if (!((!vaultApprovalInitialized) || (address(vault) != address(0)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("053267:0138:003 7: Vault balance consistency: approval must be initialized for operations");
                assert(false);
            }
            if (!(bondingToken.totalSupply() <= (virtualL + virtualInputTokens))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("053552:0141:003 8: Bonding token total supply must not exceed reasonable mathematical limits");
                assert(false);
            }
            if (!((virtualK == 0) || (virtualK > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("053812:0138:003 9: Virtual K maintains mathematical integrity as constant product formula");
                assert(false);
            }
            if (!(((alpha == 0) || (beta == 0)) || (alpha == beta))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("054084:0143:003 10: Alpha and beta must be mathematically consistent for proper curve behavior");
                assert(false);
            }
            if (!((alpha == 0) || (alpha <= (fundingGoal * 10)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("054358:0127:003 11: Slippage protection: virtual parameters must be reasonable");
                assert(false);
            }
            if (!((fundingGoal == 0) || (bondingToken.totalSupply() <= fundingGoal))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("054636:0143:003 12: Token supply management: bonding token supply must not exceed funding goal");
                assert(false);
            }
            if (!(bondingToken.totalSupply() >= 0)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("054896:0132:003 13: Token supply consistency: total supply starts at zero and grows");
                assert(false);
            }
            if (!((virtualK == 0) || (virtualL > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("055147:0132:003 14: Supply bounds: virtual L must be positive when virtual K is set");
                assert(false);
            }
            if (!((!locked) || true)) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("055382:0143:003 15: Cross-function state consistency: locked state must prevent all operations");
                assert(false);
            }
            if (!((virtualK == 0) || (virtualK > 0))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("055644:0143:003 16: Add/remove liquidity state consistency: virtual pair maintains K invariant");
                assert(false);
            }
            if (!((virtualK == 0) || (virtualInputTokens <= fundingGoal))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("055927:0157:003 17: State consistency across operations: virtual input tokens should not exceed funding goal");
                assert(false);
            }
            if (!((!vaultApprovalInitialized) || (address(inputToken) != address(0)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("056236:0135:003 18: Pre/post condition linkage: vault approval required for operations");
                assert(false);
            }
            if (!((virtualK == 0) || ((virtualL > 0) && (bondingToken.totalSupply() >= 0)))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("056529:0158:003 19: Cross-function invariant: virtual L and bonding token supply remain mathematically linked");
                assert(false);
            }
            if (!((withdrawalFeeBasisPoints >= 0) && (withdrawalFeeBasisPoints <= 10000))) {
                emit __ScribbleUtilsLib__1741.AssertionFailed("056843:0136:003 20: Withdrawal fee must be within valid range (0 to 10000 basis points)");
                assert(false);
            }
        }
    }

    /// Check the state invariant for the current contract and all its bases
    function __scribble_check_state_invariants() virtual override(ReentrancyGuard, Ownable) internal {
        __scribble_Behodler3Tokenlaunch_check_state_invariants_internal();
        __scribble_Ownable_check_state_invariants_internal();
        __scribble_Context_check_state_invariants_internal();
        __scribble_ReentrancyGuard_check_state_invariants_internal();
    }

    function _callsite_1168(IERC20 receiver, address arg0, uint256 arg1) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        (ret0) = receiver.approve(arg0, arg1);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1199(IERC20 receiver, address arg0, uint256 arg1) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        (ret0) = receiver.approve(arg0, arg1);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1227(IERC20 receiver, address arg0, uint256 arg1) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        (ret0) = receiver.approve(arg0, arg1);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1376(IERC20 receiver, address arg0, address arg1, uint256 arg2) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        (ret0) = receiver.transferFrom(arg0, arg1, arg2);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1392(IVault receiver, address arg0, uint256 arg1, address arg2) private {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        receiver.deposit(arg0, arg1, arg2);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1403(IBondingToken receiver, address arg0, uint256 arg1) private {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        receiver.mint(arg0, arg1);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1495(IBondingToken receiver, address arg0, uint256 arg1) private {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        receiver.burn(arg0, arg1);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1524(IVault receiver, address arg0, uint256 arg1, address arg2) private {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        receiver.withdraw(arg0, arg1, arg2);
        __ScribbleUtilsLib__1741.setInContract(true);
    }

    function _callsite_1532(IERC20 receiver, address arg0, uint256 arg1) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__1741.setInContract(false);
        (ret0) = receiver.transfer(arg0, arg1);
        __ScribbleUtilsLib__1741.setInContract(true);
    }
}

library __ScribbleUtilsLib__1741 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}