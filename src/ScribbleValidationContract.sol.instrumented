/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
/// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/// #invariant {:msg "Balance must equal or be less than total deposits"} balance <= totalDeposits;
///  #invariant {:msg "Total deposits must be non-negative"} totalDeposits >= 0;
///  #invariant {:msg "Balance must be non-negative"} balance >= 0;
contract ScribbleValidationContract {
    event Deposit(address indexed user, uint amount);

    event Withdraw(address indexed user, uint amount);

    struct vars1 {
        uint256 old_0;
        uint256 old_1;
        uint256 old_2;
    }

    struct vars2 {
        uint256 old_3;
        uint256 old_4;
    }

    uint public balance;
    uint public totalDeposits;
    mapping(address => uint) public userDeposits;

    function deposit(uint amount) external {
        vars1 memory _v;
        __ScribbleUtilsLib__127.setInContract(true);
        unchecked {
            _v.old_0 = balance;
            _v.old_1 = totalDeposits;
            _v.old_2 = userDeposits[msg.sender];
        }
        _original_ScribbleValidationContract_deposit(amount);
        unchecked {
            if (!(balance == (_v.old_0 + amount))) {
                emit __ScribbleUtilsLib__127.AssertionFailed("001276:0098:000 3: Balance must increase by amount");
                assert(false);
            }
            if (!(totalDeposits == (_v.old_1 + amount))) {
                emit __ScribbleUtilsLib__127.AssertionFailed("001496:0105:000 4: Total deposits must increase by amount");
                assert(false);
            }
            if (!(userDeposits[msg.sender] == (_v.old_2 + amount))) {
                emit __ScribbleUtilsLib__127.AssertionFailed("001734:0103:000 5: User deposit must increase by amount");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__127.setInContract(false);
    }

    function _original_ScribbleValidationContract_deposit(uint amount) internal {
        require(amount > 0, "Amount must be positive");
        balance += amount;
        totalDeposits += amount;
        userDeposits[msg.sender] += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint amount) external {
        vars2 memory _v;
        __ScribbleUtilsLib__127.setInContract(true);
        unchecked {
            _v.old_3 = balance;
            _v.old_4 = userDeposits[msg.sender];
        }
        _original_ScribbleValidationContract_withdraw(amount);
        unchecked {
            if (!(balance == (_v.old_3 - amount))) {
                emit __ScribbleUtilsLib__127.AssertionFailed("002678:0098:000 6: Balance must decrease by amount");
                assert(false);
            }
            if (!(userDeposits[msg.sender] == (_v.old_4 - amount))) {
                emit __ScribbleUtilsLib__127.AssertionFailed("002909:0103:000 7: User deposit must decrease by amount");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__127.setInContract(false);
    }

    function _original_ScribbleValidationContract_withdraw(uint amount) internal {
        require(amount > 0, "Amount must be positive");
        require(userDeposits[msg.sender] >= amount, "Insufficient user balance");
        require(balance >= amount, "Insufficient contract balance");
        balance -= amount;
        userDeposits[msg.sender] -= amount;
        emit Withdraw(msg.sender, amount);
    }

    function getBalance() external view returns (uint) {
        return balance;
    }

    function getUserDeposit(address user) external view returns (uint) {
        return userDeposits[user];
    }

    /// Check only the current contract's state invariants
    function __scribble_ScribbleValidationContract_check_state_invariants_internal() internal {
        unchecked {
            if (!(balance <= totalDeposits)) {
                emit __ScribbleUtilsLib__127.AssertionFailed("004027:0116:000 0: Balance must equal or be less than total deposits");
                assert(false);
            }
            if (!(totalDeposits >= 0)) {
                emit __ScribbleUtilsLib__127.AssertionFailed("004247:0102:000 1: Total deposits must be non-negative");
                assert(false);
            }
            if (!(balance >= 0)) {
                emit __ScribbleUtilsLib__127.AssertionFailed("004447:0095:000 2: Balance must be non-negative");
                assert(false);
            }
        }
    }

    /// Check the state invariant for the current contract and all its bases
    function __scribble_check_state_invariants() virtual internal {
        __scribble_ScribbleValidationContract_check_state_invariants_internal();
    }

    constructor() {
        __ScribbleUtilsLib__127.setInContract(true);
        __scribble_check_state_invariants();
        __ScribbleUtilsLib__127.setInContract(false);
    }
}

library __ScribbleUtilsLib__127 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}